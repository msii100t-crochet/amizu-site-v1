<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>編み図メーカー（かぎ針）</title>
  <style>
    :root { --bg:#fff; --fg:#111; --muted:#666; --card:#f5f5f7; --line:#e6e6ea; }
    body { margin:0; font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:20px 16px; border-bottom:1px solid var(--line); position:sticky; top:0; background:rgba(255,255,255,.9); backdrop-filter: blur(6px); z-index:5; }
    header h1 { margin:0; font-size:18px; }
    header p { margin:6px 0 0; color:var(--muted); font-size:13px; }
    main { padding:18px 16px 40px; max-width: 980px; margin:0 auto; }
    .grid { display:grid; gap:12px; grid-template-columns: 1fr; }
    @media (min-width: 900px){ .grid{ grid-template-columns: 1.2fr .8fr; } }
    .card { background:var(--card); border:1px solid var(--line); border-radius:14px; padding:14px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button { border:1px solid var(--line); background:#fff; border-radius:999px; padding:10px 14px; font-size:14px; }
    button:active { transform: translateY(1px); }
    button.selected { border-color:#111; }
    .small { font-size:12px; color:var(--muted); }
    .badge { display:inline-block; padding:4px 10px; border-radius:999px; background:#fff; border:1px solid var(--line); font-size:12px; color:var(--muted); }

    canvas{
      width:100%;
      height:auto;
      background:#fff;
      border:1px solid var(--line);
      border-radius:12px;
      touch-action: none;
      box-shadow: 0 10px 30px rgba(0,0,0,.08);
    }

    input[type="text"]{ width:100%; padding:10px 12px; border:1px solid var(--line); border-radius:10px; font-size:14px; background:#fff; }
    footer { padding:16px; color:var(--muted); font-size:12px; text-align:center; }
  </style>
</head>
<body>
  <header>
    <h1>編み図メーカー（かぎ針）</h1>
    <p>記号パレット → 選んだ記号をタップ/ドラッグで置けます（端末内に保存）</p>
  </header>

  <main class="grid">
    <section class="card">
      <div class="row" style="justify-content:space-between;">
        <span class="badge" id="mode">選択中：鎖</span>
        <span class="small">※スマホ：タップ/ドラッグ＋二本指ピンチで拡大</span>
      </div>

      <div class="row" style="margin-top:12px;">
        <button class="tool selected" data-type="ch">鎖</button>
        <button class="tool" data-type="sc">細編み</button>
        <button class="tool" data-type="dc">長編み</button>
        <button class="tool" data-type="erase">消しゴム</button>
      </div>

      <div style="margin-top:12px;">
        <canvas id="c" width="900" height="520"></canvas>
      </div>

      <div class="row" style="margin-top:12px;">
        <button id="undo">1つ戻す</button>
        <button id="clear">全部消す</button>
        <button id="savepng">PNG保存</button>
      </div>

      <p class="small" style="margin:10px 0 0;">
        使い方：上で記号を選ぶ → キャンバスをタップ/ドラッグで配置。消しゴムは近い記号を削除します。
      </p>
    </section>

    <aside class="card">
      <h2 style="margin:0 0 10px; font-size:16px;">タイトル</h2>
      <input id="title" type="text" placeholder="例）コースター 1段目" />
      <p class="small">タイトルも端末内に保存されます。</p>

      <hr style="border:none;border-top:1px solid var(--line); margin:14px 0;" />

      <h2 style="margin:0 0 8px; font-size:16px;">次に作る機能（予定）</h2>
      <ul class="small" style="line-height:1.7; margin:0; padding-left:18px;">
        <li>スナップON/OFF切替</li>
        <li>段番号・注釈</li>
        <li>日本式記号の描画を精密化</li>
        <li>公開ギャラリー（後で）</li>
      </ul>
    </aside>
  </main>

  <footer>© 編み図メーカー（試作）</footer>

  <script>
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    const titleEl = document.getElementById("title");
    const undoBtn = document.getElementById("undo");
    const clearBtn = document.getElementById("clear");
    const savePngBtn = document.getElementById("savepng");
    const modeEl = document.getElementById("mode");
    const toolBtns = Array.from(document.querySelectorAll(".tool"));

    // --- state ---
    const KEY = "amizu_items_v3";
    const KEY_TITLE = "amizu_title_v2";
    let items = []; // {x,y,type}
    let current = "ch"; // ch / sc / dc / erase

    const LABEL = { ch: "鎖", sc: "細編み", dc: "長編み", erase: "消しゴム" };

    const GRID = 30;      // グリッド間隔
    const SNAP = true;    // スナップON（後で切替可）

    // --- drawing (drag) ---
    let isDrawing = false;
    let lastPlaced = null; // {x,y}

    // --- pinch zoom ---
    let scale = 1.0;
    const MIN_SCALE = 0.6;
    const MAX_SCALE = 2.6;
    let isPinching = false;
    let pinchStartDist = 0;
    let pinchStartScale = 1.0;
    let pinchCenter = { x: 0, y: 0 }; // ピンチ中心（キャンバス座標）
    let offset = { x: 0, y: 0 };      // 描画オフセット


    function load() {
      try { items = JSON.parse(localStorage.getItem(KEY) || "[]"); } catch { items = []; }
      titleEl.value = localStorage.getItem(KEY_TITLE) || "";
    }

    function persist() {
      localStorage.setItem(KEY, JSON.stringify(items));
      localStorage.setItem(KEY_TITLE, titleEl.value || "");
    }

    function setTool(type) {
      current = type;
      modeEl.textContent = "選択中：" + LABEL[type];
      toolBtns.forEach(b => b.classList.toggle("selected", b.dataset.type === type));
    }

    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

    function drawGrid() {
      ctx.save();
      ctx.globalAlpha = 0.14;
      ctx.strokeStyle = "#000";
      for (let x=0; x<=canvas.width; x+=GRID) {
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
      }
      for (let y=0; y<=canvas.height; y+=GRID) {
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
      }
      ctx.restore();
    }

    function drawTitle() {
      ctx.fillStyle = "#111";
      ctx.font = "22px sans-serif";
      ctx.fillText(titleEl.value || "（タイトル未設定）", 18, 36);
    }

    function drawSymbol(type, x, y) {
      ctx.save();
      ctx.strokeStyle = "#111";
      ctx.fillStyle = "#111";
      ctx.lineWidth = 3;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      if (type === "ch") {
        ctx.beginPath();
        ctx.ellipse(x, y, 10, 7, 0, 0, Math.PI * 2);
        ctx.stroke();
      } else if (type === "sc") {
        ctx.beginPath();
        ctx.moveTo(x-8, y-8); ctx.lineTo(x+8, y+8);
        ctx.moveTo(x+8, y-8); ctx.lineTo(x-8, y+8);
        ctx.stroke();
      } else if (type === "dc") {
        ctx.beginPath();
        ctx.moveTo(x, y-12); ctx.lineTo(x, y+12);
        ctx.moveTo(x-10, y-2); ctx.lineTo(x+10, y-2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function redraw() {
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  // ★ オフセット → 拡大
  ctx.translate(offset.x, offset.y);
  ctx.scale(scale, scale);

  drawGrid();
  drawTitle();
  for (const it of items) drawSymbol(it.type, it.x, it.y);

  ctx.restore();
}


    function getPos(evt) {
      const rect = canvas.getBoundingClientRect();
      const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
      const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;

      const x = (clientX - rect.left) * (canvas.width / rect.width);
      const y = (clientY - rect.top) * (canvas.height / rect.height);

      return {
  x: (x - offset.x) / scale,
  y: (y - offset.y) / scale
};

    }

    function snapPoint(p) {
      if (SNAP) {
        p.x = Math.round(p.x / GRID) * GRID;
        p.y = Math.round(p.y / GRID) * GRID;
      }
      return p;
    }

    function dist2(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return dx*dx + dy*dy;
    }

    function findNearestIndex(p, maxPx=22) {
      if (items.length === 0) return -1;
      const max2 = maxPx*maxPx;
      let best = -1, bestD = Infinity;
      for (let i=0;i<items.length;i++){
        const d = dist2(p, items[i]);
        if (d < bestD) { bestD = d; best = i; }
      }
      return bestD <= max2 ? best : -1;
    }

    function maybePlace(p) {
      p = snapPoint(p);

      if (current === "erase") {
        const idx = findNearestIndex(p);
        if (idx !== -1) {
          items.splice(idx, 1);
          persist(); redraw();
        }
        lastPlaced = p;
        return;
      }

      if (lastPlaced && lastPlaced.x === p.x && lastPlaced.y === p.y) return;

      items.push({ x: p.x, y: p.y, type: current });
      persist(); redraw();
      lastPlaced = p;
    }

    function touchDist(t1, t2) {
      const dx = t1.clientX - t2.clientX;
      const dy = t1.clientY - t2.clientY;
      return Math.hypot(dx, dy);
    }

    function startDraw(evt) {
      if (evt.touches && evt.touches.length === 2) {
  evt.preventDefault();
  isPinching = true;

  const t1 = evt.touches[0];
  const t2 = evt.touches[1];

  pinchStartDist = touchDist(t1, t2);
  pinchStartScale = scale;

  // ★ 指2本の中心をキャンバス座標に変換
  const rect = canvas.getBoundingClientRect();
  const cx = ((t1.clientX + t2.clientX) / 2 - rect.left) * (canvas.width / rect.width);
  const cy = ((t1.clientY + t2.clientY) / 2 - rect.top) * (canvas.height / rect.height);

  pinchCenter = {
    x: (cx - offset.x) / scale,
    y: (cy - offset.y) / scale
  };

  return;
}


      evt.preventDefault();
      if (isPinching) return;

      isDrawing = true;
      lastPlaced = null;
      const p = getPos(evt);
      maybePlace(p);
    }

    function moveDraw(evt) {
      if (evt.touches && evt.touches.length === 2 && isPinching) {
        evt.preventDefault();
        const d = touchDist(evt.touches[0], evt.touches[1]);
        const nextScale = clamp(
  pinchStartScale * (d / pinchStartDist),
  MIN_SCALE,
  MAX_SCALE
);

// ★ 中心がズレないよう offset を再計算
offset.x = (pinchCenter.x * scale + offset.x) - (pinchCenter.x * nextScale);
offset.y = (pinchCenter.y * scale + offset.y) - (pinchCenter.y * nextScale);

scale = nextScale;
redraw();
return;

      }

      if (!isDrawing) return;
      if (isPinching) return;

      evt.preventDefault();
      const p = getPos(evt);
      maybePlace(p);
    }

    function endDraw(evt) {
      evt.preventDefault();

      if (evt.touches && evt.touches.length < 2) {
        isPinching = false;
      } else if (!evt.touches) {
        // mouseup のとき
        isPinching = false;
      }

      isDrawing = false;
      lastPlaced = null;
    }

    // mouse
    canvas.addEventListener("mousedown", startDraw);
    canvas.addEventListener("mousemove", moveDraw);
    window.addEventListener("mouseup", endDraw);

    // touch
    canvas.addEventListener("touchstart", startDraw, { passive: false });
    canvas.addEventListener("touchmove", moveDraw, { passive: false });
    window.addEventListener("touchend", endDraw, { passive: false });
    window.addEventListener("touchcancel", endDraw, { passive: false });

    titleEl.addEventListener("input", () => { persist(); redraw(); });

    toolBtns.forEach(btn => {
  const handler = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setTool(btn.dataset.type);
  };
  btn.addEventListener("click", handler);
  btn.addEventListener("touchstart", handler, { passive: false });
});


    function bindTap(el, fn) {
  const handler = (e) => {
    e.preventDefault();
    e.stopPropagation();
    fn();
  };
  el.addEventListener("click", handler);
  el.addEventListener("touchstart", handler, { passive: false });
}

bindTap(undoBtn, () => {
  items.pop();
  persist(); redraw();
});

bindTap(clearBtn, () => {
  if (!confirm("全部消しますか？")) return;
  items = [];
  persist(); redraw();
});

bindTap(savePngBtn, () => {
  const a = document.createElement("a");
  a.href = canvas.toDataURL("image/png");
  a.download = (titleEl.value || "amizu") + ".png";
  a.click();
});


    load();
    setTool("ch");
    redraw();
  </script>
</body>
</html>
